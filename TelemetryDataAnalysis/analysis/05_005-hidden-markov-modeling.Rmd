---
title: "Hidden Markov Modeling"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "#>", dpi = 500)
source(here::here("start.R"))
theme_set(theme_minimal())
set.seed(0)
```


```{r}
suppressPackageStartupMessages(library(depmixS4))
```

# Exploratoring the data

Load in some push-up data and explore the numbers.

```{r}
all_data_files <- get_data_file_names(data_dir)
raw_pushup_data <- read_watch_data(all_data_files[2])

raw_pushup_telemetry_data <- raw_pushup_data$telemetry_data
```

Plot the data over time.

```{r}
line_plot_telemetry <- function(df, x = value) {
  df %>%
    ggplot(aes(idx, {{ x }})) +
    facet_wrap(~ motion, ncol = 1, scales = "free_y") +
    geom_line(aes(color = axis), alpha = 0.7) +
    scale_color_brewer(type = "qual", palette = "Dark2")
}

line_plot_telemetry(raw_pushup_telemetry_data)
```

Subset just the portions of the data where the push-ups are.
This is some usefuly "clean" data for initial model fitting and testing.

```{r}
clean_pushup_data <- raw_pushup_telemetry_data %>%
  filter(between(idx, 250, 1400))
line_plot_telemetry(clean_pushup_data) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) +
  labs(title = "Subsetted push-up data")
```

## Data transformations

### Smoothened data

The `ksmooth` function from the 'stats' package has 2 kernel methods: *normal* and *box*.

```{r}
clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(smooth_value = ksmooth(date, value, kernel = "normal")$y)
  ungroup()
} %>%
  line_plot_telemetry(smooth_value)
```

```{r}
clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(smooth_value = ksmooth(date, value, kernel = "box")$y)
  ungroup()
} %>%
  line_plot_telemetry(smooth_value)
```

In general, smoothing the data seems to have a larger effect on the acceleration data.
Because the acceleration seems to oscillate back and forth very rapidly, the smoothing just crishes it back towards 0.

```{r}
clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(smooth_value = ksmooth(date, value, kernel = "normal")$y)
  ungroup()
  filter(between(idx, 600, 1000))
  pivot_longer(
    -c(date, idx, axis, motion),
    names_to = "transformation",
    values_to = "value"
  )
  filter(motion == "acceleration")
} %>%
  ggplot(aes(idx, value)) +
  facet_wrap(~ axis, ncol = 1) +
  geom_line(aes(color = axis, alpha = transformation, size = transformation)) +
  scale_color_brewer(type = "qual", palette = "Set1") +
  scale_size_manual(values = c(2, 1)) +
  scale_alpha_manual(values = c(0.7, 0.4))
```

Perhaps, a running measure of values could be informative.

```{r}
# Performs an action `fxn` on a running basis over `x`.
running_fxn <- function(x, fxn, n = 5) {
  y <- x
  for (i in seq(1, length(x))) {
    x_i <- c()
    for (j in seq(-n, n)) {
      idx <- i + j
      if (idx < 1 | idx > length(x)) { next }
      x_i <- c(x_i, x[[idx]])
    }
    y[[i]] <- fxn(x_i)
  }
  return(y)
}
```

Below are plots of the acceleration data with a few different transformations.
A possible conclusion is that it may not be the actual acceleration values that matter, but how variable the data is.
The `smooth_abs_max` value looks very promising. 
It is the smoothened version of `running_abs_max` which is maximum absolute value on a running-basis (Â± 10 positions on either side).

```{r}

clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(
    running_var = running_fxn(value, fxn = var, n = 10),
    running_abs_max = running_fxn(abs(value), fxn = max, n = 10),
    smooth_abs_value = ksmooth(date, abs(value), kernel = "box")$y,
    smooth_abs_max = ksmooth(date, running_abs_max, kernel = "box")$y
  )
  ungroup()
  filter(between(idx, 600, 800))
  pivot_longer(
    -c(date, idx, axis, motion),
    names_to = "transformation",
    values_to = "value"
  )
  filter(motion == "acceleration")
}%>%
  ggplot(aes(idx, value)) +
  facet_grid(axis ~ transformation) +
  geom_line(aes(color = transformation), alpha = 0.8) +
  scale_color_brewer(type = "qual", palette = "Set1", guide = FALSE) 
```

The smoothening method on the cleaned push-up data.

```{r}
clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(
    running_abs_max = running_fxn(abs(value), fxn = max, n = 10),
    smooth_abs_max = ksmooth(date, running_abs_max, kernel = "box")$y
  )
  ungroup()
} %>%
  line_plot_telemetry(smooth_abs_max)
```

The smoothening method on the raw push-up data (all of the data, not just the clipped middle portion).

```{r}
raw_pushup_telemetry_data %.% {
  group_by(axis, motion)
  mutate(
    running_abs_max = running_fxn(abs(value), fxn = max, n = 10),
    smooth_abs_max = ksmooth(date, running_abs_max, kernel = "box")$y
  )
  ungroup()
} %>%
  line_plot_telemetry(smooth_abs_max)
```

### Scaled data

```{r}
zscale <- function(x, na.rm = TRUE) {
  (x - mean(x, na.rm = na.rm)) / sd(x, na.rm = na.rm)
}


clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(
    scaled_value = zscale(value)
  )
  ungroup()
} %>%
  line_plot_telemetry(scaled_value)
```

Applying the smoothing method from above to scaled data.

```{r}
clean_pushup_data %.% {
  group_by(axis, motion)
  mutate(
    scaled_value = zscale(value),
    running_abs_max = running_fxn(abs(scaled_value), fxn = max, n = 10),
    smooth_abs_max = ksmooth(date, running_abs_max, kernel = "box")$y
    
  )
  ungroup()
} %>%
  line_plot_telemetry(smooth_abs_max)
```

The scaled smooth data looks very promising.

```{r}
raw_pushup_telemetry_data %.% {
  group_by(axis, motion)
  mutate(
    scaled_value = zscale(value),
    running_abs_max = running_fxn(abs(scaled_value), fxn = max, n = 10),
    smooth_abs_max = ksmooth(date, running_abs_max, kernel = "box")$y
    
  )
  ungroup()
} %>%
  line_plot_telemetry(smooth_abs_max)
```

## Exploration of Hidden Markov Models (HMM)

```{r}
pivot_telemetry_data <- function(telemetry_data) {
  telemetry_data %>%
    pivot_wider(
      c(date, idx),
      names_from = axis,
      values_from = value
    )
}


construct_full_telemetry_hmm_model <- function(d, nstates) {
  depmix(
    list(
      x ~ 1,
      y ~ 1,
      z ~ 1,
      pitch ~ 1,
      roll ~ 1,
      yaw ~ 1
    ),
    nstates = nstates,
    family = list(
      gaussian(), gaussian(), gaussian(),
      gaussian(), gaussian(), gaussian()
    ),
    data = d
  )
}


construct_accel_telemetry_hmm_model <- function(d, nstates) {
  depmix(
    list(
      x ~ 1,
      y ~ 1,
      z ~ 1
    ),
    nstates = nstates,
    family = list(gaussian(), gaussian(), gaussian()),
    data = d
  )
}


construct_attitude_telemetry_hmm_model <- function(d, nstates) {
  depmix(
    list(
      pitch ~ 1,
      roll ~ 1,
      yaw ~ 1
    ),
    nstates = nstates,
    family = list(gaussian(), gaussian(), gaussian()),
    data = d
  )
}
```

```{r}
pushup_data_wide <- pivot_telemetry_data(clean_pushup_data)

hmm_construction_functions <- c(
  construct_full_telemetry_hmm_model,
  construct_accel_telemetry_hmm_model,
  construct_attitude_telemetry_hmm_model
)

hmm_cleaned_models <- tibble(
  nstates = rep(c(2, 3), 3),
  fxn = rep(hmm_construction_functions, each = 2)
) %>%
  mutate(
    model = map2(fxn, nstates, ~ .x(d = pushup_data_wide, nstates = .y)),
    fit = map(model, fit),
    aic = map_dbl(fit, AIC),
    bic = map_dbl(fit, BIC)
  )

hmm_cleaned_models
```

```{r}
plot_hmm_results <- function(hmm_fit) {
  posterior(hmm_fit) %>%
    as_tibble() %>%
    mutate(idx = row_number()) %>%
    pivot_longer(-c(idx, state)) %>%
    ggplot(aes(x = idx, y = value, color = name)) +
    facet_grid(name ~ .) +
    geom_line(size = 1.2, alpha = 0.8) +
    scale_color_brewer(type = "qual", palette = "Set1") +
    scale_y_continuous(breaks = c(0, 0.5, 1)) +
    theme(
      plot.title = element_text(hjust = 0.5, size = 11, face = "bold"),
    ) +
    labs(
      x = "data point",
      y = "probability of state",
      color = "state",
      title = "Hidden Markov Model states"
    )
}


data_and_hmm_plot <- function(model_data, hmm_fit) {
  data_p <- model_data %>%
    mutate(motion_type = str_to_title(axis)) %>%
    line_plot_telemetry() +
    labs(
      x = NULL,
      y = "value"
    ) +
    theme(
      strip.text = element_text(size = 11, face = "bold")
    )

  hmm_p <- plot_hmm_results(hmm_fit)

  data_p / hmm_p
}
```

```{r}
get_best_model <- function(model_df) {
  model_df$fit[which.min(model_df$aic)][[1]]
}

best_cleaned_model <- get_best_model(hmm_cleaned_models)
summary(best_cleaned_model)
```

```{r}
data_and_hmm_plot(clean_pushup_data, best_cleaned_model) +
  plot_layout(heights = c(2, 1))
```


```{r}
raw_pushup_wide <- pivot_telemetry_data(raw_pushup_telemetry_data)

hmm_raw_models <- tibble(
  nstates = c(2:5),
  fxn = rep(c(construct_full_telemetry_hmm_model), 4)
) %>%
  mutate(
    model = map2(fxn, nstates, ~ .x(d = raw_pushup_wide, nstates = .y)),
    fit = map(model, fit),
    aic = map_dbl(fit, AIC),
    bic = map_dbl(fit, BIC)
  )

hmm_raw_models
```

```{r}
best_raw_model <- get_best_model(hmm_raw_models)
summary(best_raw_model)
```
```{r}
data_and_hmm_plot(raw_pushup_telemetry_data, best_raw_model) +
  plot_layout(heights = c(2, 1))
```

